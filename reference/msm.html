<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Multi-state Markov and hidden Markov models in continuous time — msm • msm</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Multi-state Markov and hidden Markov models in continuous time — msm"><meta name="description" content="Fit a continuous-time Markov or hidden Markov multi-state model by maximum
likelihood. Observations of the process can be made at arbitrary times, or
the exact times of transition between states can be known.  Covariates can
be fitted to the Markov chain transition intensities or to the hidden Markov
observation process."><meta property="og:description" content="Fit a continuous-time Markov or hidden Markov multi-state model by maximum
likelihood. Observations of the process can be made at arbitrary times, or
the exact times of transition between states can be known.  Covariates can
be fitted to the Markov chain transition intensities or to the hidden Markov
observation process."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">msm</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.8</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/chjackson/msm/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Multi-state Markov and hidden Markov models in continuous time</h1>
      <small class="dont-index">Source: <a href="https://github.com/chjackson/msm/blob/master/R/msm.R" class="external-link"><code>R/msm.R</code></a></small>
      <div class="d-none name"><code>msm.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Fit a continuous-time Markov or hidden Markov multi-state model by maximum
likelihood. Observations of the process can be made at arbitrary times, or
the exact times of transition between states can be known.  Covariates can
be fitted to the Markov chain transition intensities or to the hidden Markov
observation process.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">msm</span><span class="op">(</span></span>
<span>  <span class="va">formula</span>,</span>
<span>  subject <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  <span class="va">qmatrix</span>,</span>
<span>  gen.inits <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  ematrix <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  hmodel <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  obstype <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  obstrue <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  covariates <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  covinits <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  constraint <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  misccovariates <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  misccovinits <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  miscconstraint <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  hcovariates <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  hcovinits <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  hconstraint <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  hranges <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  qconstraint <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  econstraint <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  initprobs <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  est.initprobs <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  initcovariates <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  initcovinits <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  deathexact <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  death <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  exacttimes <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  censor <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  censor.states <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  pci <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  phase.states <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  phase.inits <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  subject.weights <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  cl <span class="op">=</span> <span class="fl">0.95</span>,</span>
<span>  fixedpars <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  center <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  opt.method <span class="op">=</span> <span class="st">"optim"</span>,</span>
<span>  hessian <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  use.deriv <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  use.expm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  analyticp <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  na.action <span class="op">=</span> <span class="va">na.omit</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-formula">formula<a class="anchor" aria-label="anchor" href="#arg-formula"></a></dt>
<dd><p>A formula giving the vectors containing the observed states
and the corresponding observation times. For example,</p>
<p><code>state ~ time</code></p>
<p>Observed states should be numeric variables in the set <code>1, ...{}, n</code>,
where <code>n</code> is the number of states.  Factors are allowed only if their
levels are called <code>"1", ...{}, "n"</code>.</p>
<p>The times can indicate different types of observation scheme, so be careful
to choose the correct <code>obstype</code>.</p>
<p>For hidden Markov models, <code>state</code> refers to the outcome variable, which
need not be a discrete state.  It may also be a matrix, giving multiple
observations at each time (see <code><a href="hmmMV.html">hmmMV</a></code>).</p></dd>


<dt id="arg-subject">subject<a class="anchor" aria-label="anchor" href="#arg-subject"></a></dt>
<dd><p>Vector of subject identification numbers for the data
specified by <code>formula</code>. If missing, then all observations are assumed
to be on the same subject. These must be sorted so that all observations on
the same subject are adjacent.</p></dd>


<dt id="arg-data">data<a class="anchor" aria-label="anchor" href="#arg-data"></a></dt>
<dd><p>Optional data frame in which to interpret the variables supplied
in <code>formula</code>, <code>subject</code>, <code>covariates</code>, <code>misccovariates</code>,
<code>hcovariates</code>, <code>obstype</code> and <code>obstrue</code>.</p></dd>


<dt id="arg-qmatrix">qmatrix<a class="anchor" aria-label="anchor" href="#arg-qmatrix"></a></dt>
<dd><p>Matrix which indicates the allowed transitions in the
continuous-time Markov chain, and optionally also the initial values of
those transitions. If an instantaneous transition is not allowed from state
\(r\) to state \(s\), then <code>qmatrix</code> should have \((r,s)\) entry
0, otherwise it should be non-zero.</p>
<p>If supplying initial values yourself, then the non-zero entries should be
those values.  If using <code>gen.inits=TRUE</code> then the non-zero entries can
be anything you like (conventionally 1).  Any diagonal entry of
<code>qmatrix</code> is ignored, as it is constrained to be equal to minus the sum
of the rest of the row.</p>
<p>For example,<br></p>
<p><code> rbind( c( 0, 0.1, 0.01 ), c( 0.1, 0, 0.2 ), c( 0, 0, 0 ) ) </code><br></p>
<p>represents a 'health - disease - death' model, with initial transition
intensities 0.1 from health to disease, 0.01 from health to death, 0.1 from
disease to health, and 0.2 from disease to death.</p>
<p>If the states represent ordered levels of severity of a disease, then this
matrix should usually only allow transitions between adjacent states.  For
example, if someone was observed in state 1 ("mild") at their first
observation, followed by state 3 ("severe") at their second observation,
they are assumed to have passed through state 2 ("moderate") in between, and
the 1,3 entry of <code>qmatrix</code> should be zero.</p>
<p>The initial intensities given here are with any covariates set to their
means in the data (or set to zero, if <code>center = FALSE</code>). If any
intensities are constrained to be equal using <code>qconstraint</code>, then the
initial value is taken from the first of these (reading across rows).</p></dd>


<dt id="arg-gen-inits">gen.inits<a class="anchor" aria-label="anchor" href="#arg-gen-inits"></a></dt>
<dd><p>If <code>TRUE</code>, then initial values for the transition
intensities are generated automatically using the method in
<code><a href="crudeinits.msm.html">crudeinits.msm</a></code>. The non-zero entries of the supplied
<code>qmatrix</code> are assumed to indicate the allowed transitions of the model.
This is not available for hidden Markov models, including models with
misclassified states.</p></dd>


<dt id="arg-ematrix">ematrix<a class="anchor" aria-label="anchor" href="#arg-ematrix"></a></dt>
<dd><p>If misclassification between states is to be modelled, this
should be a matrix of initial values for the misclassification
probabilities.  The rows represent underlying states, and the columns
represent observed states.  If an observation of state \(s\) is not
possible when the subject occupies underlying state \(r\), then
<code>ematrix</code> should have \((r,s)\) entry 0.  Otherwise <code>ematrix</code>
should have \((r,s)\) entry corresponding to the probability of observing
\(s\) conditionally on occupying true state \(r\). The diagonal of
<code>ematrix</code> is ignored, as rows are constrained to sum to 1.  For
example, <br></p>
<p><code> rbind( c( 0, 0.1, 0 ), c( 0.1, 0, 0.1 ), c( 0, 0.1, 0 ) ) </code><br></p>
<p>represents a model in which misclassifications are only permitted between
adjacent states.</p>
<p>If any probabilities are constrained to be equal using <code>econstraint</code>,
then the initial value is taken from the first of these (reading across
rows).</p>
<p>For an alternative way of specifying misclassification models, see
<code>hmodel</code>.</p></dd>


<dt id="arg-hmodel">hmodel<a class="anchor" aria-label="anchor" href="#arg-hmodel"></a></dt>
<dd><p>Specification of the hidden Markov model (HMM).  This should
be a list of return values from HMM constructor functions.  Each element of
the list corresponds to the outcome model conditionally on the corresponding
underlying state.  Univariate constructors are described in
the<code><a href="hmm-dists.html">hmm-dists</a></code> help page.  These may also be grouped together to
specify a multivariate HMM with a set of conditionally independent
univariate outcomes at each time, as described in <code><a href="hmmMV.html">hmmMV</a></code>.</p>
<p>For example, consider a three-state hidden Markov model.  Suppose the
observations in underlying state 1 are generated from a Normal distribution
with mean 100 and standard deviation 16, while observations in underlying
state 2 are Normal with mean 54 and standard deviation 18. Observations in
state 3, representing death, are exactly observed, and coded as 999 in the
data.  This model is specified as</p>
<p><code>hmodel = list(hmmNorm(mean=100, sd=16), hmmNorm(mean=54, sd=18),
hmmIdent(999))</code></p>
<p>The mean and standard deviation parameters are estimated starting from these
initial values. If multiple parameters are constrained to be equal using
<code>hconstraint</code>, then the initial value is taken from the value given on
the first occasion that parameter appears in <code>hmodel</code>.</p>
<p>See the <code><a href="hmm-dists.html">hmm-dists</a></code> help page for details of the constructor
functions for each univariate distribution.</p>
<p>A misclassification model, that is, a hidden Markov model where the outcomes
are misclassified observations of the underlying states, can either be
specified using a list of <code><a href="hmm-dists.html">hmmCat</a></code> or <code><a href="hmm-dists.html">hmmIdent</a></code>
objects, or by using an <code>ematrix</code>.</p>
<p>For example, <br></p>
<p><code> ematrix = rbind( c( 0, 0.1, 0, 0 ), c( 0.1, 0, 0.1, 0 ), c( 0, 0.1,
0, 0), c( 0, 0, 0, 0) ) </code><br></p>
<p>is equivalent to <br></p>
<p><code>hmodel = list( hmmCat(prob=c(0.9, 0.1, 0, 0)), hmmCat(prob=c(0.1, 0.8,
0.1, 0)), hmmCat(prob=c(0, 0.1, 0.9, 0)), hmmIdent()) </code><br></p></dd>


<dt id="arg-obstype">obstype<a class="anchor" aria-label="anchor" href="#arg-obstype"></a></dt>
<dd><p>A vector specifying the observation scheme for each row of
the data. This can be included in the data frame <code>data</code> along with the
state, time, subject IDs and covariates.  Its elements should be either 1, 2
or 3, meaning as follows:</p>
<dl><dt>1</dt>
<dd><p>An observation of the process at an arbitrary time (a
"snapshot" of the process, or "panel-observed" data). The states are unknown
between observation times.</p></dd>
 <dt>2</dt>
<dd><p>An exact transition time, with the
state at the previous observation retained until the current observation.
An observation may represent a transition to a different state or a repeated
observation of the same state (e.g. at the end of follow-up).  Note that if
all transition times are known, more flexible models could be fitted with
packages other than <span class="pkg">msm</span> - see the note under <code>exacttimes</code>.</p>
<p>Note also that if the previous state was censored using <code>censor</code>, for
example known only to be state 1 or state 2, then <code>obstype</code> 2 means
that either state 1 is retained or state 2 is retained until the current
observation - this does not allow for a change of state in the middle of the
observation interval.</p></dd>
 <dt>3</dt>
<dd><p>An exact transition time, but the state at
the instant before entering this state is unknown. A common example is death
times in studies of chronic diseases.</p></dd>

</dl><p>If <code>obstype</code> is not specified,
this defaults to all 1. If <code>obstype</code> is a single number, all
observations are assumed to be of this type.  The obstype value for the
first observation from each subject is not used.</p>
<p>This is a generalisation of the <code>deathexact</code> and <code>exacttimes</code>
arguments to allow different schemes per observation.  <code>obstype</code>
overrides both <code>deathexact</code> and <code>exacttimes</code>.</p>
<p><code>exacttimes=TRUE</code> specifies that all observations are of obstype 2.</p>
<p><code>deathexact = death.states</code> specifies that all observations of
<code>death.states</code> are of type 3.  <code>deathexact = TRUE</code> specifies that
all observations in the final absorbing state are of type 3.</p></dd>


<dt id="arg-obstrue">obstrue<a class="anchor" aria-label="anchor" href="#arg-obstrue"></a></dt>
<dd><p>In misclassification models specified with <code>ematrix</code>,
<code>obstrue</code> is a vector of logicals (<code>TRUE</code> or <code>FALSE</code>) or
numerics (1 or 0) specifying which observations (<code>TRUE</code>, 1) are
observations of the underlying state without error, and which (<code>FALSE</code>,
0) are realisations of a hidden Markov model.</p>
<p>In HMMs specified with <code>hmodel</code>, where the hidden state is known at
some times, if <code>obstrue</code> is supplied it is assumed to contain the
actual true state data.  Elements of <code>obstrue</code> at times when the hidden
state is unknown are set to <code>NA</code>.  This allows the information from HMM
outcomes generated conditionally on the known state to be included in the
model, thus improving the estimation of the HMM outcome distributions.</p>
<p>HMMs where the true state is known to be within a specific set at specific
times can be defined with a combination of <code>censor</code> and <code>obstrue</code>.
In these models, a code is defined for the <code>state</code> outcome (see
<code>censor</code>), and <code>obstrue</code> is set to 1 for observations where the
true state is known to be one of the elements of <code>censor.states</code> at the
corresponding time.</p></dd>


<dt id="arg-covariates">covariates<a class="anchor" aria-label="anchor" href="#arg-covariates"></a></dt>
<dd><p>A formula or a list of formulae representing the
covariates on the transition intensities via a log-linear model. If a single
formula is supplied, like</p>
<p><code>covariates = ~ age + sex + treatment</code></p>
<p>then these covariates are assumed to apply to all intensities.  If a named
list is supplied, then this defines a potentially different model for each
named intensity.  For example,</p>
<p><code>covariates = list("1-2" = ~ age, "2-3" = ~ age + treatment)</code></p>
<p>specifies an age effect on the state 1 - state 2 transition, additive age
and treatment effects on the state 2 - state 3 transition, but no covariates
on any other transitions that are allowed by the <code>qmatrix</code>.</p>
<p>If covariates are time dependent, they are assumed to be constant in between
the times they are observed, and the transition probability between a pair
of times \((t1, t2)\) is assumed to depend on the covariate value at
\(t1\).</p></dd>


<dt id="arg-covinits">covinits<a class="anchor" aria-label="anchor" href="#arg-covinits"></a></dt>
<dd><p>Initial values for log-linear effects of covariates on the
transition intensities. This should be a named list with each element
corresponding to a covariate.  A single element contains the initial values
for that covariate on each transition intensity, reading across the rows in
order.  For a pair of effects constrained to be equal, the initial value for
the first of the two effects is used.</p>
<p>For example, for a model with the above <code>qmatrix</code> and age and sex
covariates, the following initialises all covariate effects to zero apart
from the age effect on the 2-1 transition, and the sex effect on the 1-3
transition.  <code> covinits = list(sex=c(0, 0, 0.1, 0), age=c(0, 0.1, 0,
0))</code></p>
<p>For factor covariates, name each level by concatenating the name of the
covariate with the level name, quoting if necessary. For example, for a
covariate <code>agegroup</code> with three levels <code>0-15, 15-60, 60-</code>, use
something like</p>
<p><code> covinits = list("agegroup15-60"=c(0, 0.1, 0, 0), "agegroup60-"=c(0.1,
0.1, 0, 0))</code></p>
<p>If not specified or wrongly specified, initial values are assumed to be
zero.</p></dd>


<dt id="arg-constraint">constraint<a class="anchor" aria-label="anchor" href="#arg-constraint"></a></dt>
<dd><p>A list of one numeric vector for each named covariate. The
vector indicates which covariate effects on intensities are constrained to
be equal. Take, for example, a model with five transition intensities and
two covariates. Specifying<br></p>
<p><code>constraint = list (age = c(1,1,1,2,2), treatment = c(1,2,3,4,5))</code><br></p>
<p>constrains the effect of age to be equal for the first three intensities,
and equal for the fourth and fifth. The effect of treatment is assumed to be
different for each intensity. Any vector of increasing numbers can be used
as indicators. The intensity parameters are assumed to be ordered by reading
across the rows of the transition matrix, starting at the first row,
ignoring the diagonals.</p>
<p>Negative elements of the vector can be used to indicate that particular
covariate effects are constrained to be equal to minus some other effects.
For example:</p>
<p><code>constraint = list (age = c(-1,1,1,2,-2), treatment = c(1,2,3,4,5))
</code><br></p>
<p>constrains the second and third age effects to be equal, the first effect to
be minus the second, and the fifth age effect to be minus the fourth.  For
example, it may be realisitic that the effect of a covariate on the
"reverse" transition rate from state 2 to state 1 is minus the effect on the
"forward" transition rate, state 1 to state 2.  Note that it is not possible
to specify exactly which of the covariate effects are constrained to be
positive and which negative.  The maximum likelihood estimation chooses the
combination of signs which has the higher likelihood.</p>
<p>For categorical covariates, defined as factors, specify constraints as
follows:<br></p>
<p><code>list(..., covnameVALUE1 = c(...), covnameVALUE2 = c(...), ...)</code><br></p>
<p>where <code>covname</code> is the name of the factor, and <code>VALUE1</code>,
<code>VALUE2</code>, ... are the labels of the factor levels (usually excluding
the baseline, if using the default contrasts).</p>
<p>Make sure the <code>contrasts</code> option is set appropriately, for example, the
default</p>
<p><code>options(contrasts=c(contr.treatment, contr.poly))</code></p>
<p>sets the first (baseline) level of unordered factors to zero, then the
baseline level is ignored in this specification.</p>
<p>To assume no covariate effect on a certain transition, use the
<code>fixedpars</code> argument to fix it at its initial value (which is zero by
default) during the optimisation.</p></dd>


<dt id="arg-misccovariates">misccovariates<a class="anchor" aria-label="anchor" href="#arg-misccovariates"></a></dt>
<dd><p>A formula representing the covariates on the
misclassification probabilities, analogously to <code>covariates</code>, via
multinomial logistic regression. Only used if the model is specified using
<code>ematrix</code>, rather than <code>hmodel</code>.</p>
<p>This must be a single formula - lists are not supported, unlike
<code>covariates</code>.  If a different model on each probability is required,
include all covariates in this formula, and use <code>fixedpars</code> to fix some
of their effects (for particular probabilities) at their default initial
values of zero.</p></dd>


<dt id="arg-misccovinits">misccovinits<a class="anchor" aria-label="anchor" href="#arg-misccovinits"></a></dt>
<dd><p>Initial values for the covariates on the
misclassification probabilities, defined in the same way as <code>covinits</code>.
Only used if the model is specified using <code>ematrix</code>.</p></dd>


<dt id="arg-miscconstraint">miscconstraint<a class="anchor" aria-label="anchor" href="#arg-miscconstraint"></a></dt>
<dd><p>A list of one vector for each named covariate on
misclassification probabilities. The vector indicates which covariate
effects on misclassification probabilities are constrained to be equal,
analogously to <code>constraint</code>.  Only used if the model is specified using
<code>ematrix</code>.</p></dd>


<dt id="arg-hcovariates">hcovariates<a class="anchor" aria-label="anchor" href="#arg-hcovariates"></a></dt>
<dd><p>List of formulae the same length as <code>hmodel</code>,
defining any covariates governing the hidden Markov outcome models.  The
covariates operate on a suitably link-transformed linear scale, for example,
log scale for a Poisson outcome model. If there are no covariates for a
certain hidden state, then insert a NULL in the corresponding place in the
list.  For example, <code>hcovariates = list(~acute + age, ~acute, NULL).</code></p></dd>


<dt id="arg-hcovinits">hcovinits<a class="anchor" aria-label="anchor" href="#arg-hcovinits"></a></dt>
<dd><p>Initial values for the hidden Markov model covariate
effects. A list of the same length as <code>hcovariates</code>. Each element is a
vector with initial values for the effect of each covariate on that state.
For example, the above <code>hcovariates</code> can be initialised with
<code>hcovariates = list(c(-8, 0), -8, NULL)</code>. Initial values must be given
for all or no covariates, if none are given these are all set to zero.  The
initial value given in the <code>hmodel</code> constructor function for the
corresponding baseline parameter is interpreted as the value of that
parameter with any covariates fixed to their means in the data.  If multiple
effects are constrained to be equal using <code>hconstraint</code>, then the
initial value is taken from the first of the multiple initial values
supplied.</p></dd>


<dt id="arg-hconstraint">hconstraint<a class="anchor" aria-label="anchor" href="#arg-hconstraint"></a></dt>
<dd><p>A named list. Each element is a vector of constraints on
the named hidden Markov model parameter. The vector has length equal to the
number of times that class of parameter appears in the whole model.</p>
<p>For example consider the three-state hidden Markov model described above,
with normally-distributed outcomes for states 1 and 2.  To constrain the
outcome variance to be equal for states 1 and 2, and to also constrain the
effect of <code>acute</code> on the outcome mean to be equal for states 1 and 2,
specify</p>
<p><code>hconstraint = list(sd = c(1,1), acute=c(1,1))</code></p>
<p>Note this excludes initial state occupancy probabilities and covariate
effects on those probabilities, which cannot be constrained.</p></dd>


<dt id="arg-hranges">hranges<a class="anchor" aria-label="anchor" href="#arg-hranges"></a></dt>
<dd><p>Range constraints for hidden Markov model parameters.
Supplied as a named list, with each element corresponding to the named
hidden Markov model parameter.  This element is itself a list with two
elements, vectors named "lower" and "upper".  These vectors each have length
equal to the number of times that class of parameter appears in the whole
model, and give the corresponding mininum amd maximum allowable values for
that parameter.  Maximum likelihood estimation is performed with these
parameters constrained in these ranges (through a log or logit-type
transformation).  Lower bounds of <code>-Inf</code> and upper bounds of <code>Inf</code>
can be given if the parameter is unbounded above or below.</p>
<p>For example, in the three-state model above, to constrain the mean for state
1 to be between 0 and 6, and the mean of state 2 to be between 7 and 12,
supply</p>
<p><code>hranges=list(mean=list(lower=c(0, 7), upper=c(6, 12)))</code></p>
<p>These default to the natural ranges, e.g. the positive real line for
variance parameters, and [0,1] for probabilities.  Therefore <code>hranges</code>
need not be specified for such parameters unless an even stricter constraint
is desired.  If only one limit is supplied for a parameter, only the first
occurrence of that parameter is constrained.</p>
<p>Initial values should be strictly within any ranges, and not on the range
boundary, otherwise optimisation will fail with a "non-finite value" error.</p></dd>


<dt id="arg-qconstraint">qconstraint<a class="anchor" aria-label="anchor" href="#arg-qconstraint"></a></dt>
<dd><p>A vector of indicators specifying which baseline
transition intensities are equal. For example,</p>
<p><code>qconstraint = c(1,2,3,3)</code></p>
<p>constrains the third and fourth intensities to be equal, in a model with
four allowed instantaneous transitions.  When there are covariates on the
intensities and <code>center=TRUE</code> (the default), <code>qconstraint</code> is
applied to the intensities with covariates taking the values of the means in
the data.  When <code>center=FALSE</code>, <code>qconstraint</code> is applied to the
intensities with covariates set to zero.</p></dd>


<dt id="arg-econstraint">econstraint<a class="anchor" aria-label="anchor" href="#arg-econstraint"></a></dt>
<dd><p>A similar vector of indicators specifying which baseline
misclassification probabilities are constrained to be equal.  Only used if
the model is specified using <code>ematrix</code>, rather than <code>hmodel</code>.</p></dd>


<dt id="arg-initprobs">initprobs<a class="anchor" aria-label="anchor" href="#arg-initprobs"></a></dt>
<dd><p>Only used in hidden Markov models.  Underlying state
occupancy probabilities at each subject's first observation.  Can either be
a vector of \(nstates\) elements with common probabilities to all
subjects, or a \(nsubjects\) by \(nstates\) matrix of subject-specific
probabilities.  This refers to observations after missing data and subjects
with only one observation have been excluded.</p>
<p>If these are estimated (see <code>est.initprobs</code>), then this represents an
initial value, and defaults to equal probability for each state.  Otherwise
this defaults to <code>c(1, rep(0, nstates-1))</code>, that is, in state 1 with a
probability of 1.  Scaled to sum to 1 if necessary.  The state 1 occupancy
probability should be non-zero.</p></dd>


<dt id="arg-est-initprobs">est.initprobs<a class="anchor" aria-label="anchor" href="#arg-est-initprobs"></a></dt>
<dd><p>Only used in hidden Markov models.  If <code>TRUE</code>,
then the underlying state occupancy probabilities at the first observation
will be estimated, starting from a vector of initial values supplied in the
<code>initprobs</code> argument.  Structural zeroes are allowed: if any of these
initial values are zero they will be fixed at zero during optimisation, even
if <code>est.initprobs=TRUE</code>, and no covariate effects on them are
estimated.  The exception is state 1, which should have non-zero occupancy
probability.</p>
<p>Note that the free parameters during this estimation exclude the state 1
occupancy probability, which is fixed at one minus the sum of the other
probabilities.</p></dd>


<dt id="arg-initcovariates">initcovariates<a class="anchor" aria-label="anchor" href="#arg-initcovariates"></a></dt>
<dd><p>Formula representing covariates on the initial state
occupancy probabilities, via multinomial logistic regression.  The linear
effects of these covariates, observed at the individual's first observation
time, operate on the log ratio of the state \(r\) occupancy probability to
the state 1 occupancy probability, for each \(r = 2\) to the number of
states.  Thus the state 1 occupancy probability should be non-zero. If
<code>est.initprobs</code> is <code>TRUE</code>, these effects are estimated starting
from their initial values.  If <code>est.initprobs</code> is <code>FALSE</code>, these
effects are fixed at theit initial values.</p></dd>


<dt id="arg-initcovinits">initcovinits<a class="anchor" aria-label="anchor" href="#arg-initcovinits"></a></dt>
<dd><p>Initial values for the covariate effects
<code>initcovariates</code>.  A named list with each element corresponding to a
covariate, as in <code>covinits</code>. Each element is a vector with (1 - number
of states) elements, containing the initial values for the linear effect of
that covariate on the log odds of that state relative to state 1, from state
2 to the final state.  If <code>initcovinits</code> is not specified, all
covariate effects are initialised to zero.</p></dd>


<dt id="arg-deathexact">deathexact<a class="anchor" aria-label="anchor" href="#arg-deathexact"></a></dt>
<dd><p>Vector of indices of absorbing states whose time of entry
is known exactly, but the individual is assumed to be in an unknown
transient state ("alive") at the previous instant.  This is the usual
situation for times of death in chronic disease monitoring data.  For
example, if you specify <code>deathexact = c(4, 5)</code> then states 4 and 5 are
assumed to be exactly-observed death states.</p>
<p>See the <code>obstype</code> argument.  States of this kind correspond to
<code>obstype=3</code>. <code>deathexact = TRUE</code> indicates that the final
absorbing state is of this kind, and <code>deathexact = FALSE</code> or
<code>deathexact = NULL</code> (the default) indicates that there is no state of
this kind.</p>
<p>The <code>deathexact</code> argument is overridden by <code>obstype</code> or
<code>exacttimes</code>.</p>
<p>Note that you do not always supply a <code>deathexact</code> argument, even if
there are states that correspond to deaths, because they do not necessarily
have <code>obstype=3</code>.  If the state is known between the time of death and
the previous observation, then you should specify <code>obstype=2</code> for the
death times, or <code>exacttimes=TRUE</code> if the state is known at all times,
and the <code>deathexact</code> argument is ignored.</p></dd>


<dt id="arg-death">death<a class="anchor" aria-label="anchor" href="#arg-death"></a></dt>
<dd><p>Old name for the <code>deathexact</code> argument.  Overridden by
<code>deathexact</code> if both are supplied. Deprecated.</p></dd>


<dt id="arg-exacttimes">exacttimes<a class="anchor" aria-label="anchor" href="#arg-exacttimes"></a></dt>
<dd><p>By default, the transitions of the Markov process are
assumed to take place at unknown occasions in between the observation times.
If <code>exacttimes</code> is set to <code>TRUE</code>, then the observation times are
assumed to represent the exact times of transition of the process.  The
subject is assumed to be in the same state between these times.  An
observation may represent a transition to a different state or a repeated
observation of the same state (e.g. at the end of follow-up).  This is
equivalent to every row of the data having <code>obstype = 2</code>.  See the
<code>obstype</code> argument.  If both <code>obstype</code> and <code>exacttimes</code> are
specified then <code>exacttimes</code> is ignored.</p>
<p>Note that the complete history of the multi-state process is known with this
type of data.  The models which <span class="pkg">msm</span> fits have the strong assumption of
constant (or piecewise-constant) transition rates.  Knowing the exact
transition times allows more realistic models to be fitted with other
packages.  For example parametric models with sojourn distributions more
flexible than the exponential can be fitted with the <span class="pkg">flexsurv</span> package,
or semi-parametric models can be implemented with <span class="pkg">survival</span> in
conjunction with <span class="pkg">mstate</span>.</p></dd>


<dt id="arg-censor">censor<a class="anchor" aria-label="anchor" href="#arg-censor"></a></dt>
<dd><p>A state, or vector of states, which indicates censoring.
Censoring means that the observed state is known only to be one of a
particular set of states. For example, <code>censor=999</code> indicates that all
observations of <code>999</code> in the vector of observed states are censored
states.  By default, this means that the true state could have been any of
the transient (non-absorbing) states. To specify corresponding true states
explicitly, use a <code>censor.states</code> argument.</p>
<p>Note that in contrast to the usual terminology of survival analysis, here it
is the <em>state</em> which is considered to be censored, rather than the
<em>event time</em>.  If at the end of a study, an individual has not died,
but their true state is <em>known</em>, then <code>censor</code> is unnecessary,
since the standard multi-state model likelihood is applicable.  Also a
"censored" state here can be at any time, not just at the end.</p>
<p>For hidden Markov models, censoring may indicate either a set of possible
observed states, or a set of (hidden) true states. The later case is
specified by setting the relevant elements of <code>obstrue</code> to 1 (and
<code>NA</code> otherwise).</p>
<p>Note in particular that general time-inhomogeneous Markov models with
piecewise constant transition intensities can be constructed using the
<code>censor</code> facility. If the true state is unknown on occasions when a
piecewise constant covariate is known to change, then censored states can be
inserted in the data on those occasions.  The covariate may represent time
itself, in which case the <code>pci</code> option to msm can be used to perform
this trick automatically, or some other time-dependent variable.</p>
<p>Not supported for multivariate hidden Markov models specified with
<code><a href="hmmMV.html">hmmMV</a></code>.</p></dd>


<dt id="arg-censor-states">censor.states<a class="anchor" aria-label="anchor" href="#arg-censor-states"></a></dt>
<dd><p>Specifies the underlying states which censored
observations can represent. If <code>censor</code> is a single number (the
default) this can be a vector, or a list with one element.  If <code>censor</code>
is a vector with more than one element, this should be a list, with each
element a vector corresponding to the equivalent element of <code>censor</code>.
For example</p>
<p><code>censor = c(99, 999), censor.states = list(c(2,3), c(3,4))</code></p>
<p>means that observations coded 99 represent either state 2 or state 3, while
observations coded 999 are really either state 3 or state 4.</p></dd>


<dt id="arg-pci">pci<a class="anchor" aria-label="anchor" href="#arg-pci"></a></dt>
<dd><p>Model for piecewise-constant intensities.  Vector of cut points
defining the times, since the start of the process, at which intensities
change for all subjects.  For example</p>
<p><code>pci = c(5, 10)</code></p>
<p>specifies that the intensity changes at time points 5 and 10.  This will
automatically construct a model with a categorical (factor) covariate called
<code>timeperiod</code>, with levels <code>"[-Inf,5)"</code>, <code>"[5,10)"</code> and
<code>"[10,Inf)"</code>, where the first level is the baseline.  This covariate
defines the time period in which the observation was made.  Initial values
and constraints on covariate effects are specified the same way as for a
model with a covariate of this name, for example,</p>
<p><code>covinits = list("timeperiod[5,10)"=c(0.1,0.1),
"timeperiod[10,Inf)"=c(0.1,0.1))</code></p>
<p>Thus if <code>pci</code> is supplied, you cannot have a previously-existing
variable called <code>timeperiod</code> as a covariate in any part of a <code>msm</code>
model.</p>
<p>To assume piecewise constant intensities for some transitions but not others
with <code>pci</code>, use the <code>fixedpars</code> argument to fix the appropriate
covariate effects at their default initial values of zero.</p>
<p>Internally, this works by inserting censored observations in the data at
times when the intensity changes but the state is not observed.</p>
<p>If the supplied times are outside the range of the time variable in the
data, <code>pci</code> is ignored and a time-homogeneous model is fitted.</p>
<p>After fitting a time-inhomogeneous model, <code><a href="qmatrix.msm.html">qmatrix.msm</a></code> can be
used to obtain the fitted intensity matrices for each time period, for
example,</p>
<p><code>qmatrix.msm(example.msm, covariates=list(timeperiod="[5,Inf)"))</code></p>
<p>This facility does not support interactions between time and other
covariates.  Such models need to be specified "by hand", using a state
variable with censored observations inserted.  Note that the <code>data</code>
component of the <code>msm</code> object returned from a call to <code>msm</code> with
<code>pci</code> supplied contains the states with inserted censored observations
and time period indicators.  These can be used to construct such models.</p>
<p>Note that you do not need to use <code>pci</code> in order to model the effect of
a time-dependent covariate in the data.  <code>msm</code> will automatically
assume that covariates are piecewise-constant and change at the times when
they are observed.  <code>pci</code> is for when you want all intensities to
change at the same pre-specified times for all subjects.</p>
<p><code>pci</code> is not supported for multivariate hidden Markov models specified with
<code><a href="hmmMV.html">hmmMV</a></code>.   An approximate equivalent can be constructed by
creating a variable in the data to represent the time period, and treating
that as a covariate using the <code>covariates</code> argument to <code>msm</code>.
This will assume that the value of this variable is constant between
observations.</p></dd>


<dt id="arg-phase-states">phase.states<a class="anchor" aria-label="anchor" href="#arg-phase-states"></a></dt>
<dd><p>Indices of states which have a two-phase sojourn
distribution.  This defines a semi-Markov model, in which the hazard of an
onward transition depends on the time spent in the state.</p>
<p>This uses the technique described by Titman and Sharples (2009).  A hidden
Markov model is automatically constructed on an expanded state space, where
the phases correspond to the hidden states.  The "tau" proportionality
constraint described in this paper is currently not supported.</p>
<p>Covariates, constraints, <code>deathexact</code> and <code>censor</code> are expressed
with respect to the expanded state space.  If not supplied by hand,
<code>initprobs</code> is defined automatically so that subjects are assumed to
begin in the first of the two phases.</p>
<p>Hidden Markov models can additionally be given phased states.  The user
supplies an outcome distribution for each original state using
<code>hmodel</code>, which is expanded internally so that it is assumed to be the
same within each of the phased states.  <code>initprobs</code> is interpreted on
the expanded state space.  Misclassification models defined using
<code>ematrix</code> are not supported, and these must be defined using
<code>hmmCat</code> or <code>hmmIdent</code> constructors, as described in the
<code>hmodel</code> section of this help page.  Or the HMM on the expanded state
space can be defined by hand.</p>
<p>Output functions are presented as it were a hidden Markov model on the
expanded state space, for example, transition probabilities between states,
covariate effects on transition rates, or prevalence counts, are not
aggregated over the hidden phases.</p>
<p>Numerical estimation will be unstable when there is weak evidence for a
two-phase sojourn distribution, that is, if the model is close to Markov.</p>
<p>See <code><a href="twophase.html">d2phase</a></code> for the definition of the two-phase distribution
and the interpretation of its parameters.</p>
<p>This is an experimental feature, and some functions are not implemented.
Please report any experiences of using this feature to the author!</p></dd>


<dt id="arg-phase-inits">phase.inits<a class="anchor" aria-label="anchor" href="#arg-phase-inits"></a></dt>
<dd><p>Initial values for phase-type models.  A list with one
component for each "two-phased" state.  Each component is itself a list of
two elements.  The first of these elements is a scalar defining the
transition intensity from phase 1 to phase 2.  The second element is a
matrix, with one row for each potential destination state from the
two-phased state, and two columns.  The first column is the transition rate
from phase 1 to the destination state, and the second column is the
transition rate from phase 2 to the destination state.  If there is only one
destination state, then this may be supplied as a vector.</p>
<p>In phase type models, the initial values for transition rates out of
non-phased states are taken from the <code>qmatrix</code> supplied to msm, and
entries of this matrix corresponding to transitions out of phased states are
ignored.</p></dd>


<dt id="arg-subject-weights">subject.weights<a class="anchor" aria-label="anchor" href="#arg-subject-weights"></a></dt>
<dd><p>Name of a variable in the data (unquoted) giving
  weights to apply to each subject in the data
  when calculating the log-likelihood as a weighted sum over
  subjects.  These are taken from the first observation for each
  subject, and any weights supplied for subsequent observations are
  not used.</p>
<p>Weights at the observation level are not supported.</p></dd>


<dt id="arg-cl">cl<a class="anchor" aria-label="anchor" href="#arg-cl"></a></dt>
<dd><p>Width of symmetric confidence intervals for maximum likelihood
estimates, by default 0.95.</p></dd>


<dt id="arg-fixedpars">fixedpars<a class="anchor" aria-label="anchor" href="#arg-fixedpars"></a></dt>
<dd><p>Vector of indices of parameters whose values will be fixed
at their initial values during the optimisation. These are given in the
order: transition intensities (reading across rows of the transition
matrix), covariates on intensities (ordered by intensities within
covariates), hidden Markov model parameters, including misclassification
probabilities or parameters of HMM outcome distributions (ordered by
parameters within states), hidden Markov model covariate parameters (ordered
by covariates within parameters within states), initial state occupancy
probabilities (excluding the first probability, which is fixed at one minus
the sum of the others).</p>
<p>If there are equality constraints on certain parameters, then
<code>fixedpars</code> indexes the set of unique parameters, excluding those which
are constrained to be equal to previous parameters.</p>
<p>To fix all parameters, specify <code>fixedpars = TRUE</code>.</p>
<p>This can be useful for profiling likelihoods, and building complex models
stage by stage.</p></dd>


<dt id="arg-center">center<a class="anchor" aria-label="anchor" href="#arg-center"></a></dt>
<dd><p>If <code>TRUE</code> (the default, unless <code>fixedpars=TRUE</code>)
then covariates are centered at their means during the maximum likelihood
estimation. This usually improves stability of the numerical optimisation.</p></dd>


<dt id="arg-opt-method">opt.method<a class="anchor" aria-label="anchor" href="#arg-opt-method"></a></dt>
<dd><p>If "optim", "nlm" or "bobyqa", then the corresponding R
function will be used for maximum likelihood estimation.
<code><a href="https://rdrr.io/r/stats/optim.html" class="external-link">optim</a></code> is the default.  "bobyqa" requires the package
<span class="pkg">minqa</span> to be installed.  See the help of these functions for further
details.  Advanced users can also add their own optimisation methods, see
the source for <code>optim.R</code> in msm for some examples.</p>
<p>If "fisher", then a specialised Fisher scoring method is used (Kalbfleisch
and Lawless, 1985) which can be faster than the generic methods, though less
robust.  This is only available for Markov models with panel data
(<code>obstype=1</code>), that is, not for models with censored states, hidden
Markov models, exact observation or exact death times (<code>obstype=2,3</code>).</p></dd>


<dt id="arg-hessian">hessian<a class="anchor" aria-label="anchor" href="#arg-hessian"></a></dt>
<dd><p>If <code>TRUE</code> then standard errors and confidence intervals
are obtained from a numerical estimate of the Hessian (the observed
information matrix).  This is the default when maximum likelihood estimation
is performed.  If all parameters are fixed at their initial values and no
optimisation is performed, then this defaults to <code>FALSE</code>.  If
requested, the actual Hessian is returned in <code>x$paramdata$opt$hessian</code>,
where <code>x</code> is the fitted model object.</p>
<p>If <code>hessian</code> is set to <code>FALSE</code>, then standard errors and
confidence intervals are obtained from the Fisher (expected) information
matrix, if this is available.  This may be preferable if the numerical
estimation of the Hessian is computationally intensive, or if the resulting
estimate is non-invertible or not positive definite.</p></dd>


<dt id="arg-use-deriv">use.deriv<a class="anchor" aria-label="anchor" href="#arg-use-deriv"></a></dt>
<dd><p>If <code>TRUE</code> then analytic first derivatives are used in
the optimisation of the likelihood, where available and an appropriate
quasi-Newton optimisation method, such as BFGS, is being used.  Analytic
derivatives are not available for all models.</p></dd>


<dt id="arg-use-expm">use.expm<a class="anchor" aria-label="anchor" href="#arg-use-expm"></a></dt>
<dd><p>If <code>TRUE</code> then any matrix exponentiation needed to
calculate the likelihood is done using the <span class="pkg">expm</span> package.  Otherwise
the original routines used in <span class="pkg">msm</span> 1.2.4 and earlier are used.  Set to
<code>FALSE</code> for backward compatibility, and let the package maintainer know
if this gives any substantive differences.</p></dd>


<dt id="arg-analyticp">analyticp<a class="anchor" aria-label="anchor" href="#arg-analyticp"></a></dt>
<dd><p>By default, the likelihood for certain simpler 3, 4 and 5
state models is calculated using an analytic expression for the transition
probability (P) matrix. For all other models, matrix exponentiation is used
to obtain P. To revert to the original method of using the matrix
exponential for all models, specify <code>analyticp=FALSE</code>. See the PDF
manual for a list of the models for which analytic P matrices are
implemented.</p></dd>


<dt id="arg-na-action">na.action<a class="anchor" aria-label="anchor" href="#arg-na-action"></a></dt>
<dd><p>What to do with missing data: either <code>na.omit</code> to drop
it and carry on, or <code>na.fail</code> to stop with an error.  Missing data
includes all NAs in the states, times, <code>subject</code> or <code>obstrue</code>, all
NAs at the first observation for a subject for covariates in
<code>initcovariates</code>, all NAs in other covariates (excluding the last
observation for a subject), all NAs in <code>obstype</code> (excluding the first
observation for a subject), and any subjects with only one observation (thus
no observed transitions).</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>Optional arguments to the general-purpose optimisation routine,
<code><a href="https://rdrr.io/r/stats/optim.html" class="external-link">optim</a></code> by default. For example <code>method="Nelder-Mead"</code> to
change the optimisation algorithm from the <code>"BFGS"</code> method that msm
calls by default.</p>
<p>It is often worthwhile to normalize the optimisation using
<code>control=list(fnscale = a)</code>, where <code>a</code> is the a number of the
order of magnitude of the -2 log likelihood.</p>
<p>If 'false' convergence is reported and the standard errors cannot be
calculated due to a non-positive-definite Hessian, then consider tightening
the tolerance criteria for convergence. If the optimisation takes a long
time, intermediate steps can be printed using the <code>trace</code> argument of
the control list. See <code><a href="https://rdrr.io/r/stats/optim.html" class="external-link">optim</a></code> for details.</p>
<p>For the Fisher scoring method, a <code>control</code> list can be supplied in the
same way, but the only supported options are <code>reltol</code>, <code>trace</code> and
<code>damp</code>.  The first two are used in the same way as for
<code><a href="https://rdrr.io/r/stats/optim.html" class="external-link">optim</a></code>.  If the algorithm fails with a singular information
matrix, adjust <code>damp</code> from the default of zero (to, e.g. 1).  This adds
a constant identity matrix multiplied by <code>damp</code> to the information
matrix during optimisation.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>To obtain summary information from models fitted by the
<code>msm</code> function, it is recommended to use extractor functions
such as <code><a href="qmatrix.msm.html">qmatrix.msm</a></code>, <code><a href="pmatrix.msm.html">pmatrix.msm</a></code>,
<code><a href="sojourn.msm.html">sojourn.msm</a></code>, <code><a href="msm.form.qoutput.html">msm.form.qoutput</a></code>.  These provide
estimates and confidence intervals for quantities such as transition
probabilities for given covariate values.</p>
<p>For advanced use, it may be necessary to directly use information stored in
the object returned by <code>msm</code>.  This is documented in the help
page <code><a href="msm.object.html">msm.object</a></code>.</p>
<p>Printing a <code>msm</code> object by typing the object's name at the command line
implicitly invokes <code><a href="print.msm.html">print.msm</a></code>.  This formats and prints the
important information in the model fit, and also returns that information in
an R object.  This includes estimates and confidence intervals for the
transition intensities and (log) hazard ratios for the corresponding
covariates. When there is a hidden Markov model, the chief information in
the <code>hmodel</code> component is also formatted and printed. This includes
estimates and confidence intervals for each parameter.</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>For full details about the methodology behind the <span class="pkg">msm</span> package, refer
to the PDF manual <code class="file">msm-manual.pdf</code> in the <code class="file">doc</code> subdirectory of
the package. This includes a tutorial in the typical use of <span class="pkg">msm</span>.  The
paper by Jackson (2011) in Journal of Statistical Software presents the
material in this manual in a more concise form.</p>
<p><span class="pkg">msm</span> was designed for fitting <em>continuous-time</em> Markov models,
processes where transitions can occur at any time.  These models are defined
by <em>intensities</em>, which govern both the time spent in the current state
and the probabilities of the next state.  In <em>discrete-time models</em>,
transitions are known in advance to only occur at multiples of some time
unit, and the model is purely governed by the probability distributions of
the state at the next time point, conditionally on the state at the current
time. These can also be fitted in <span class="pkg">msm</span>, assuming that there is a
continuous-time process underlying the data.  Then the fitted transition
probability matrix over one time period, as returned by
<code>pmatrix.msm(...,t=1)</code> is equivalent to the matrix that governs the
discrete-time model. However, these can be fitted more efficiently using
multinomial logistic regression, for example, using <code>multinom</code> from the
R package <span class="pkg">nnet</span> (Venables and Ripley, 2002).</p>
<p>For simple continuous-time multi-state Markov models, the likelihood is
calculated in terms of the transition intensity matrix \(Q\). When the
data consist of observations of the Markov process at arbitrary times, the
exact transition times are not known.  Then the likelihood is calculated
using the transition probability matrix \(P(t) = \exp(tQ)\), where \(\exp\) is the matrix exponential.  If state \(i\)
is observed at time \(t\) and state \(j\) is observed at time \(u\),
then the contribution to the likelihood from this pair of observations is
the \(i,j\) element of \(P(u - t)\). See, for example, Kalbfleisch and
Lawless (1985), Kay (1986), or Gentleman <em>et al.</em> (1994).</p>
<p>For hidden Markov models, the likelihood for an individual with \(k\)
observations is calculated directly by summing over the unknown state at
each time, producing a product of \(k\) matrices. The calculation is a
generalisation of the method described by Satten and Longini (1996), and
also by Jackson and Sharples (2002), and Jackson <em>et al.</em> (2003).</p>
<p>There must be enough information in the data on each state to estimate each
transition rate, otherwise the likelihood will be flat and the maximum will
not be found.  It may be appropriate to reduce the number of states in the
model, the number of allowed transitions, or the number of covariate
effects, to ensure convergence.  Hidden Markov models, and situations where
the value of the process is only known at a series of snapshots, are
particularly susceptible to non-identifiability, especially when combined
with a complex transition matrix.  Choosing an appropriate set of initial
values for the optimisation can also be important.  For flat likelihoods,
'informative' initial values will often be required.  See the PDF manual for
other tips.</p>
    </div>
    <div class="section level2">
    <h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a></h2>
    <p>Jackson, C.H. (2011). Multi-State Models for Panel Data: The msm
Package for R., Journal of Statistical Software, 38(8), 1-29. URL
http://www.jstatsoft.org/v38/i08/.</p>
<p>Kalbfleisch, J., Lawless, J.F., The analysis of panel data under a Markov
assumption <em>Journal of the Americal Statistical Association</em> (1985)
80(392): 863–871.</p>
<p>Kay, R.  A Markov model for analysing cancer markers and disease states in
survival studies.  <em>Biometrics</em> (1986) 42: 855–865.</p>
<p>Gentleman, R.C., Lawless, J.F., Lindsey, J.C. and Yan, P.  Multi-state
Markov models for analysing incomplete disease history data with
illustrations for HIV disease.  <em>Statistics in Medicine</em> (1994) 13(3):
805–821.</p>
<p>Satten, G.A. and Longini, I.M.  Markov chains with measurement error:
estimating the 'true' course of a marker of the progression of human
immunodeficiency virus disease (with discussion) <em>Applied Statistics</em>
45(3): 275-309 (1996)</p>
<p>Jackson, C.H. and Sharples, L.D. Hidden Markov models for the onset and
progression of bronchiolitis obliterans syndrome in lung transplant
recipients <em>Statistics in Medicine</em>, 21(1): 113–128 (2002).</p>
<p>Jackson, C.H., Sharples, L.D., Thompson, S.G. and Duffy, S.W. and Couto, E.
Multi-state Markov models for disease progression with classification error.
<em>The Statistician</em>, 52(2): 193–209 (2003)</p>
<p>Titman, A.C. and Sharples, L.D.  Semi-Markov models with phase-type sojourn
distributions.  <em>Biometrics</em> 66, 742-752 (2009).</p>
<p>Venables, W.N. and Ripley, B.D. (2002) <em>Modern Applied Statistics with
S</em>, second edition. Springer.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="simmulti.msm.html">simmulti.msm</a></code>, <code><a href="plot.msm.html">plot.msm</a></code>,
<code><a href="summary.msm.html">summary.msm</a></code>, <code><a href="qmatrix.msm.html">qmatrix.msm</a></code>,
<code><a href="pmatrix.msm.html">pmatrix.msm</a></code>, <code><a href="sojourn.msm.html">sojourn.msm</a></code>.</p></div>
    </div>
    <div class="section level2">
    <h2 id="author">Author<a class="anchor" aria-label="anchor" href="#author"></a></h2>
    <p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a></p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">### Heart transplant data</span></span></span>
<span class="r-in"><span><span class="co">### For further details and background to this example, see</span></span></span>
<span class="r-in"><span><span class="co">### Jackson (2011) or the PDF manual in the doc directory.</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">cav</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="op">]</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     PTNUM      age    years dage sex pdiag cumrej state firstobs statemax</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1  100002 52.49589 0.000000   21   0   IHD      0     1        1        1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2  100002 53.49863 1.002740   21   0   IHD      2     1        0        1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3  100002 54.49863 2.002740   21   0   IHD      2     2        0        2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4  100002 55.58904 3.093151   21   0   IHD      2     2        0        2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5  100002 56.49589 4.000000   21   0   IHD      3     2        0        2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6  100002 57.49315 4.997260   21   0   IHD      3     3        0        3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7  100002 58.35068 5.854795   21   0   IHD      3     4        0        4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 8  100003 29.50685 0.000000   17   0   IHD      0     1        1        1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 9  100003 30.69589 1.189041   17   0   IHD      1     1        0        1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 10 100003 31.51507 2.008219   17   0   IHD      1     3        0        3</span>
<span class="r-in"><span><span class="va">twoway4.q</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.5</span>, <span class="fl">0.25</span>, <span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.166</span>, <span class="op">-</span><span class="fl">0.498</span>, <span class="fl">0.166</span>, <span class="fl">0.166</span><span class="op">)</span>,</span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span>, <span class="op">-</span><span class="fl">0.5</span>, <span class="fl">0.25</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="statetable.msm.html">statetable.msm</a></span><span class="op">(</span><span class="va">state</span>, <span class="va">PTNUM</span>, data<span class="op">=</span><span class="va">cav</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> from    1    2    3    4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    1 1367  204   44  148</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    2   46  134   54   48</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    3    4   13  107   55</span>
<span class="r-in"><span><span class="fu"><a href="crudeinits.msm.html">crudeinits.msm</a></span><span class="op">(</span><span class="va">state</span> <span class="op">~</span> <span class="va">years</span>, <span class="va">PTNUM</span>, data<span class="op">=</span><span class="va">cav</span>, qmatrix<span class="op">=</span><span class="va">twoway4.q</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            [,1]        [,2]       [,3]       [,4]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1,] -0.1173149  0.06798932  0.0000000 0.04932559</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [2,]  0.1168179 -0.37584883  0.1371340 0.12189692</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [3,]  0.0000000  0.04908401 -0.2567471 0.20766310</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [4,]  0.0000000  0.00000000  0.0000000 0.00000000</span>
<span class="r-in"><span><span class="va">cav.msm</span> <span class="op">&lt;-</span> <span class="fu">msm</span><span class="op">(</span> <span class="va">state</span> <span class="op">~</span> <span class="va">years</span>, subject<span class="op">=</span><span class="va">PTNUM</span>, data <span class="op">=</span> <span class="va">cav</span>,</span></span>
<span class="r-in"><span>                 qmatrix <span class="op">=</span> <span class="va">twoway4.q</span>, deathexact <span class="op">=</span> <span class="fl">4</span>, </span></span>
<span class="r-in"><span>                 control <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span> <span class="op">(</span> trace <span class="op">=</span> <span class="fl">2</span>, REPORT <span class="op">=</span> <span class="fl">1</span> <span class="op">)</span>  <span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> initial  value 4908.816768 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter   2 value 4023.220496</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter   3 value 3999.817797</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter   4 value 3991.887884</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter   5 value 3988.554023</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter   6 value 3987.675350</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter   7 value 3986.235180</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter   8 value 3980.602119</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter   9 value 3972.567178</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter  10 value 3969.625128</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter  11 value 3969.152813</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter  12 value 3968.848846</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter  13 value 3968.804343</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter  14 value 3968.798404</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter  15 value 3968.797986</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter  16 value 3968.797903</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iter  16 value 3968.797893</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> final  value 3968.797893 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> converged</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Used 43 function and 16 gradient evaluations</span>
<span class="r-in"><span><span class="va">cav.msm</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Call:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> msm(formula = state ~ years, subject = PTNUM, data = cav, qmatrix = twoway4.q,     deathexact = 4, control = list(trace = 2, REPORT = 1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Maximum likelihood estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Transition intensities</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   Baseline                    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 1 - State 1 -0.17037 (-0.19027,-0.15255)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 1 - State 2  0.12787 ( 0.11135, 0.14684)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 1 - State 4  0.04250 ( 0.03412, 0.05294)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 2 - State 1  0.22512 ( 0.16755, 0.30247)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 2 - State 2 -0.60794 (-0.70880,-0.52143)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 2 - State 3  0.34261 ( 0.27317, 0.42970)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 2 - State 4  0.04021 ( 0.01129, 0.14324)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 3 - State 2  0.13062 ( 0.07952, 0.21457)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 3 - State 3 -0.43710 (-0.55292,-0.34554)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 3 - State 4  0.30648 ( 0.23822, 0.39429)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -2 * log-likelihood:  3968.798 </span>
<span class="r-in"><span><span class="fu"><a href="qmatrix.msm.html">qmatrix.msm</a></span><span class="op">(</span><span class="va">cav.msm</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         State 1                      State 2                     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 1 -0.17037 (-0.19027,-0.15255)  0.12787 ( 0.11135, 0.14684)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 2  0.22512 ( 0.16755, 0.30247) -0.60794 (-0.70880,-0.52143)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 3 0                             0.13062 ( 0.07952, 0.21457)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 4 0                            0                           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         State 3                      State 4                     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 1 0                             0.04250 ( 0.03412, 0.05294)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 2  0.34261 ( 0.27317, 0.42970)  0.04021 ( 0.01129, 0.14324)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 3 -0.43710 (-0.55292,-0.34554)  0.30648 ( 0.23822, 0.39429)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 4 0                            0                           </span>
<span class="r-in"><span><span class="fu"><a href="pmatrix.msm.html">pmatrix.msm</a></span><span class="op">(</span><span class="va">cav.msm</span>, t<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>            State 1    State 2    State 3   State 4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 1 0.30940656 0.09750021 0.08787255 0.5052207</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 2 0.17165172 0.06552639 0.07794394 0.6848780</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 3 0.05898093 0.02971653 0.04665485 0.8646477</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 4 0.00000000 0.00000000 0.00000000 1.0000000</span>
<span class="r-in"><span><span class="fu"><a href="sojourn.msm.html">sojourn.msm</a></span><span class="op">(</span><span class="va">cav.msm</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         estimates        SE        L        U</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 1  5.869552 0.3307930 5.255734 6.555057</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 2  1.644897 0.1288274 1.410825 1.917805</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> State 3  2.287819 0.2743666 1.808595 2.894023</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Christopher Jackson.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer></div>





  </body></html>

